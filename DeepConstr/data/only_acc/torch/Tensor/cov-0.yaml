args:
  dtype:
  - Tensor
  - int
  - Optional[Tensor]
  - Optional[Tensor]
  is_pos:
  - true
  - false
  - false
  - false
  name:
  - self
  - correction
  - fweights
  - aweights
  required:
  - true
  - false
  - false
  - false
name: torch.Tensor.cov
package: torch
pass_rate: 49.6
rules:
- - cot: ''
    target:
      choosen_dtype:
        aweights: tensor
        correction: int
        fweights: None
        self: tensor
      msg: 'cov(): expected input to have two or fewer dimensions but got an input
        with 3 dimensions'
      package: torch
    txt: self.rank <= 2
  - f1_score: 99.02912621359224
    overall_score: 100
    precision: 100.0
    recall: 98.07692307692308
- - cot: ''
    target:
      choosen_dtype:
        aweights: None
        correction: int
        fweights: tensor
        self: tensor
      msg: 'cov(): expected fweights to have one or fewer dimensions but got fweights
        with 3 dimensions'
      package: torch
    txt: fweights.rank <= 1
  - f1_score: 99.02912621359224
    overall_score: 100
    precision: 100.0
    recall: 98.07692307692308
- - cot: '`aweights` should have one or fewer dimensions. Let''s see what the dimensions
      of `aweights` are. The runtime information says that `aweights` has 5 dimensions.
      Therefore, the constraint to prevent the error is:'
    target:
      choosen_dtype:
        aweights: tensor
        correction: int
        fweights: None
        self: tensor
      msg: 'cov(): expected aweights to have one or fewer dimensions but got aweights
        with 3 dimensions'
      package: torch
    txt: aweights.rank <= 1
  - f1_score: 99.02912621359224
    overall_score: 100
    precision: 100.0
    recall: 98.07692307692308
- - cot: 'The error occurs because the function expects the ''fweights'' parameter
      to have an integral data type, but a float data type was provided. To prevent
      this error in the future and generate constraints that do not trigger it, we
      need to ensure that the ''fweights'' parameter always has an integral data type.
      The constraint for the ''fweights'' parameter can be expressed as:'
    length: 1
    target:
      choosen_dtype:
        aweights: tensor
        correction: int
        fweights: tensor
        self: tensor
      msg: 'cov(): expected fweights to have integral dtype but got fweights with
        Float dtype'
      package: torch
    txt: fweights.dtype in [torch.int16, torch.int32, torch.int64, torch.int8, torch.uint8]
  - f1_score: 100.0
    overall_score: 100
    precision: 100.0
    recall: 100.0
- - cot: default
    length: 3
    target:
      choosen_dtype:
        aweights: Optional[Tensor]
        correction: int
        fweights: Optional[Tensor]
        self: Tensor
      msg: negative dimensions are not allowed
      package: torch
    txt: all(i >= 0 for i in self.shape) and all(i >= 0 for i in fweights.shape) and
      all(i >= 0 for i in aweights.shape)
  - f1_score: -1
    overall_score: -1
    precision: -1
    recall: -1
- - cot: default
    length: 3
    target:
      choosen_dtype:
        aweights: Optional[Tensor]
        correction: int
        fweights: Optional[Tensor]
        self: Tensor
      msg: Too large tensor shape
      package: torch
    txt: self.rank <= 7 and fweights.rank <= 7 and aweights.rank <= 7
  - f1_score: -1
    overall_score: -1
    precision: -1
    recall: -1
